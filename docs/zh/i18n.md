# 国际化 (i18n)

async-zulip-bot-sdk 提供了一个轻量级的、基于 JSON 的国际化系统，让你可以轻松地为 bot 支持多种语言。

## 概述

i18n 系统的特点：

- 使用 **英文文本作为 key**（例如 `"Hello {name}"`）
- 在 per-language JSON 文件中存储翻译
- 支持 **bot 级别的翻译**（per-bot 覆盖）和 **SDK 级别的默认翻译**
- 通过 BaseBot 的 `tr()` 方法无缝集成
- 处理 **占位符替换**（`{name}`、`{count}` 等）
- **优雅降级**：缺失的翻译回退到原始 key

## 文件结构

翻译文件组织如下：

```
project_root/
├── bot_sdk/
│   └── i18n/
│       ├── en.json        # SDK 默认值（英文）
│       └── zh.json        # SDK 默认值（中文）
│
└── bots/
    ├── my_bot/
    │   ├── __init__.py
    │   ├── bot.yaml       # Bot 配置，含 language: zh
    │   └── i18n/          # Bot 特定翻译（可选）
    │       ├── en.json
    │       └── zh.json
    │
    └── other_bot/
        ├── __init__.py
        ├── bot.yaml       # language: en
        └── i18n/
            └── zh.json
```

## 配置

Per-bot 的语言在 `bot.yaml` 中设置：

```yaml
# bots/my_bot/bot.yaml
owner_user_id: 123
language: zh
role_levels:
  user: 1
  admin: 50
  bot_owner: 200
settings: {}
```

- **language**: 语言代码（例如 `"en"`、`"zh"`、`"fr"`）。默认为 `"en"`。
- BaseBot 初始化时，按以下顺序加载翻译：

  1. `<bot_dir>/i18n/{language}.json`（bot 特定覆盖）
  2. `<bot_dir>/i18n/en.json`（bot 特定回退到英文）
  3. `bot_sdk/i18n/{language}.json`（SDK 默认值）
  4. `bot_sdk/i18n/en.json`（SDK 默认值回退到英文）

## 使用方法

### 在 BaseBot 子类中

```python
from bot_sdk import BaseBot, Message, CommandSpec, CommandArgument

class MyBot(BaseBot):
    def register_commands(self):
        # 命令描述可以在注册时翻译
        self.command_parser.register_spec(
            CommandSpec(
                name="hello",
                description=self.tr("Greet a user"),  # 使用 i18n
                args=[
                    CommandArgument(
                        name="name",
                        type=str,
                        required=True,
                        description=self.tr("The name to greet")
                    ),
                ],
                handler=self.handle_hello,
            )
        )

    async def handle_hello(self, invocation, message, bot):
        name = invocation.args.get("name")
        # 翻译用户可见的消息
        reply = self.tr("Hello {name}!", name=name)
        await self.send_reply(message, reply)

    async def on_message(self, message: Message) -> None:
        # 翻译任何用户可见的文本
        await self.send_reply(
            message,
            self.tr("Thank you for your message!")
        )
```

### 命令处理器模式

```python
class MyBot(BaseBot):
    async def handle_command(self, invocation, message, bot):
        try:
            # 验证和处理
            result = self.do_something(invocation.args)
        except ValueError as e:
            # 错误消息被翻译
            await self.send_reply(
                message,
                "❌ " + self.tr("Invalid input: {error}", error=str(e))
            )
            return

        # 成功消息被翻译
        await self.send_reply(
            message,
            "✅ " + self.tr("Operation successful!")
        )
```

## 创建翻译文件

### JSON 格式

翻译是简单的键值 JSON 文件：

```json
{
  "Hello {name}!": "你好 {name}！",
  "Greet a user": "问候用户",
  "The name to greet": "要问候的用户名",
  "Invalid input: {error}": "无效的输入：{error}",
  "Operation successful!": "操作成功！",
  "Thank you for your message!": "谢谢你的消息！"
}
```

### 建议

- **使用英文作为 key**：key 应该是原始英文文本（或至少是易读的文本）。
- **在 key 中包含占位符**：像 `"Hello {name}"` 这样的 key 有助于识别值的插入位置。
- **保持一致**：在文件间保持 key 名称一致（翻译时不要改变 key）。
- **正确转义 JSON**：记得在 JSON 字符串中转义反斜杠和引号。

### Bot 特定的例子

对于 `bots/my_bot/i18n/zh.json`：

```json
{
  "Greet a user": "问候用户",
  "The name to greet": "要问候的用户名",
  "Hello {name}!": "你好 {name}！",
  "Thank you for your message!": "谢谢你的消息！"
}
```

## 内置翻译

SDK 为内置命令和 UI 字符串提供了默认翻译：

**英文** (`bot_sdk/i18n/en.json`)：

- 命令描述：Show your permission info、Manage bot permissions、Stop the bot、Reload configuration and translations
- 帮助系统：Show available commands、Description、Aliases、Min level、Args:、required、optional、multiple
- 错误：Permission denied.、Unknown command: {name}、Missing argument: {name}、Too many arguments、Invalid value for {name}: {value}、Command error: {error}
- 其他：User Info、User、Roles、Level、Configuration and translations reloaded.、Failed to reload configuration: {error}

**中文** (`bot_sdk/i18n/zh.json`)：

- 类似的中文翻译

你可以在 bot 自己的 `i18n/{language}.json` 文件中覆盖任何这些翻译。

## I18n 类

对于高级用例，你可以直接实例化 `I18n`：

```python
from bot_sdk.i18n import I18n

# 加载中文翻译，搜索多个路径
i18n = I18n(
    language="zh",
    search_paths=[
        "bots/my_bot/i18n",  # Bot 特定翻译
        "bot_sdk/i18n"        # SDK 默认值
    ],
    default_language="en"     # 回退到英文
)

# 翻译字符串
greeting = i18n.translate("Hello {name}!", name="Alice")
print(greeting)  # 输出：你好 Alice！
```

## build_i18n_for_bot 辅助函数

BaseBot 使用一个辅助函数来自动定位和加载翻译：

```python
from bot_sdk.i18n import build_i18n_for_bot

# 由 BaseBot._init_i18n() 自动调用
i18n = build_i18n_for_bot(
    language="zh",
    bot_module_name="bots.my_bot"  # 自动找到 bot 目录
)
```

这个函数会：

1. 解析 bot 模块路径
2. 搜索 `<bot_dir>/i18n` 中的翻译
3. 回退到 `bot_sdk/i18n`
4. 返回一个已准备好使用的 `I18n` 实例

## 热重载

内置的 `!reload` 命令（仅管理员可用）可以在不重启 bot 的情况下重新初始化 i18n 系统：

```
User: !reload
Bot: ✅ Configuration and translations reloaded.
```

在以下情况下很有用：
- 你编辑 `bot.yaml` 来改变 `language` 字段
- 你添加或更新翻译文件
- 你想让改动立即生效

## CommandParser 和 i18n

`CommandParser` 自动从 BaseBot 接收一个翻译函数：

```python
# 在 BaseBot.__init__ 中：
self.command_parser = CommandParser(
    prefixes=self.command_prefixes,
    enable_mentions=self.enable_mention_commands,
    auto_help=self.auto_help_command,
    translator=lambda s: self.tr(s),  # 传递 bot 的 tr 方法
)
```

这意味着：

- 命令描述在渲染帮助时被翻译
- 错误消息被本地化
- 所有帮助 UI 标签尊重 bot 的语言

## 最佳实践

1. **仅翻译用户可见的文本**

   - 为用户看到的消息使用 i18n
   - 将日志、调试消息和开发者级别的文本保留为英文

2. **使用一致的 key 命名**

   - 使用英文文本作为 key
   - 不要改变 key；相反，添加新的条目

3. **提供回退方案**

   - 始终在 SDK i18n 文件中包含英文翻译
   - 这确保即使缺少翻译，bot 也能继续工作

4. **测试多语言支持**

   - 使用 `language: en`、`language: zh` 等配置测试 bot
   - 验证占位符正确替换
   - 检查 `!reload` 是否正确切换语言

5. **组织 bot 特定的翻译**

   - 创建 `bots/my_bot/i18n/` 目录，含 `en.json` 和其他语言文件
   - 将 bot 特定翻译与 SDK 默认值分开

## 示例：多语言 bot

```python
from bot_sdk import BaseBot, Message, CommandSpec, CommandArgument, run_bot

class MultiLangBot(BaseBot):
    def register_commands(self):
        self.command_parser.register_spec(
            CommandSpec(
                name="fortune",
                description=self.tr("Tell a fortune"),
                handler=self.handle_fortune,
            )
        )

    async def handle_fortune(self, invocation, message, bot):
        fortunes = {
            "en": "Today is a good day!",
            "zh": "今天是个好日子！",
        }
        fortune = fortunes.get(self.language, "Today is a good day!")
        await self.send_reply(message, fortune)

    async def on_message(self, message: Message) -> None:
        await self.send_reply(
            message,
            self.tr("Thanks for the message, {name}!", name=message.sender_full_name)
        )

if __name__ == "__main__":
    run_bot(MultiLangBot)
```

将 `bot.yaml` 设置为 `language: zh`，此 bot 将用中文回应。使用 `!reload` 来动态切换语言。

## 故障排除

**翻译没有出现？**

- 检查 JSON 文件是否存在于预期的位置
- 验证 key 是否完全匹配（空格、大小写、占位符）
- 查看 bot 日志中的警告

**占位符没有替换？**

- 确保占位符名称与 kwarg 匹配：`tr("Hello {name}", name="Alice")` 而不是 `tr("Hello {name}", user="Alice")`
- 检查翻译 key 是否也包含占位符

**想添加新语言？**

- 创建 `bot_sdk/i18n/xx.json` 或 `bots/my_bot/i18n/xx.json`（其中 `xx` 是语言代码）
- 在 bot 的 `bot.yaml` 中设置 `language: xx`
- 使用 `!reload` 来加载新翻译

